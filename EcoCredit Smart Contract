// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

/**
 * @title EcoCredit
 * @dev ERC-20 token for rewarding environmental actions
 * Features:
 * - Role-based access control (ADMIN, RELAYER, FACILITY)
 * - Pausable for emergency stops
 * - UUPS upgradeable pattern
 * - Mint idempotency using orderId mapping
 * - Mint caps per order
 */
contract EcoCredit is
    Initializable,
    ERC20Upgradeable,
    AccessControlUpgradeable,
    PausableUpgradeable,
    UUPSUpgradeable,
    ReentrancyGuardUpgradeable
{
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant RELAYER_ROLE = keccak256("RELAYER_ROLE");
    bytes32 public constant FACILITY_ROLE = keccak256("FACILITY_ROLE");

    // Maximum credits that can be minted per order (10,000 credits = 10,000 kg)
    uint256 public constant MAX_CREDITS_PER_ORDER = 10000 * 10**18;
    
    // Track minted orders for idempotency
    mapping(string => bool) public mintedOrders;
    
    // Track total credits minted per order
    mapping(string => uint256) public orderCredits;
    
    // Events
    event CreditsMinted(
        address indexed recipient,
        uint256 amount,
        string indexed orderId,
        uint256 weightKg,
        string wasteType
    );
    
    event OrderMinted(string indexed orderId, address indexed recipient, uint256 amount);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address admin) public initializer {
        __ERC20_init("EcoCredit", "ECO");
        __AccessControl_init();
        __Pausable_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(ADMIN_ROLE, admin);
        
        // Set role hierarchy
        _setRoleAdmin(RELAYER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(FACILITY_ROLE, ADMIN_ROLE);
    }

    /**
     * @dev Mint eco credits for verified waste disposal
     * Only RELAYER can mint to ensure proper verification
     * @param to Recipient address
     * @param orderId Unique order identifier for idempotency
     * @param weightKg Weight of waste in kilograms
     * @param wasteType Type of waste (plastic, metal, etc.)
     */
    function mint(
        address to,
        string calldata orderId,
        uint256 weightKg,
        string calldata wasteType
    ) external onlyRole(RELAYER_ROLE) whenNotPaused nonReentrant {
        require(to != address(0), "EcoCredit: mint to zero address");
        require(bytes(orderId).length > 0, "EcoCredit: empty orderId");
        require(weightKg > 0, "EcoCredit: zero weight");
        require(!mintedOrders[orderId], "EcoCredit: order already minted");

        // Calculate credits: 1 credit per kg of waste
        uint256 credits = weightKg * 10**decimals();
        require(credits <= MAX_CREDITS_PER_ORDER, "EcoCredit: exceeds max credits per order");

        // Mark order as minted
        mintedOrders[orderId] = true;
        orderCredits[orderId] = credits;

        // Mint tokens
        _mint(to, credits);

        emit CreditsMinted(to, credits, orderId, weightKg, wasteType);
        emit OrderMinted(orderId, to, credits);
    }

    /**
     * @dev Batch mint for multiple orders
     */
    function batchMint(
        address[] calldata recipients,
        string[] calldata orderIds,
        uint256[] calldata weights,
        string[] calldata wasteTypes
    ) external onlyRole(RELAYER_ROLE) whenNotPaused {
        require(
            recipients.length == orderIds.length &&
            orderIds.length == weights.length &&
            weights.length == wasteTypes.length,
            "EcoCredit: array length mismatch"
        );

        for (uint256 i = 0; i < recipients.length; i++) {
            if (!mintedOrders[orderIds[i]]) {
                mint(recipients[i], orderIds[i], weights[i], wasteTypes[i]);
            }
        }
    }

    /**
     * @dev Check if an order has been minted
     */
    function isOrderMinted(string calldata orderId) external view returns (bool) {
        return mintedOrders[orderId];
    }

    /**
     * @dev Get credits minted for an order
     */
    function getOrderCredits(string calldata orderId) external view returns (uint256) {
        return orderCredits[orderId];
    }

    /**
     * @dev Pause contract (admin only)
     */
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }

    /**
     * @dev Unpause contract (admin only)
     */
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }

    /**
     * @dev Required for UUPS upgrades
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyRole(ADMIN_ROLE) {}

    /**
     * @dev Override to add pausable functionality to transfers
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, amount);
    }

    /**
     * @dev Returns the number of decimals used to get user-friendly representation
     */
    function decimals() public pure override returns (uint8) {
        return 18;
    }

    /**
     * @dev Support for ERC165 interface detection
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
